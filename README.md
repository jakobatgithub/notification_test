# Notification Test Project

This project demonstrates the integration of the [django-emqx](https://github.com/jakobatgithub/django-emqx) app for Firebase Cloud Messaging (FCM) and MQTT to enable robust, real-time notification and messaging capabilities. The backend is developed using Django, while the frontend is built with Flutter, providing a cross-platform mobile application.

FCM is primarily used to deliver push notifications to the frontend when the application is inactive or running in the background. However, FCM has significant limitations when handling pure data messages or a combination of push notifications and data payloads, as its reliability varies across different device manufacturers and system configurations.

To overcome these limitations, MQTT is employed to ensure a reliable, bidirectional communication channel between the backend and the frontend. Unlike FCM, MQTT facilitates persistent connections and guarantees message delivery, making it ideal for sending arbitrary data in real-time. The MQTT implementation is powered by a self-hosted EMQX broker, allowing full control over message distribution, quality of service (QoS) levels, and connection management.

## Features

This project incorporates several security and efficiency measures to ensure seamless and secure communication between the backend and frontend.

- **Topic-based Access Control:**
    Each frontend user is restricted to a single dedicated MQTT topic for subscriptions, ensuring isolation between users. The backend, however, has the necessary permissions to publish messages to all topics, enabling efficient and controlled message distribution.

- **JWT-based Authentication & Authorization:**
    JSON Web Tokens (JWT) are used for authenticating MQTT clients at EMQX and to enforce access and control lists (ACLs). This ensures that each client has restricted access based on predefined permissions, preventing unauthorized subscriptions or publications. For JWT we use `rest_framework_simplejwt`.

- **Secure MQTT Communication with TLS:**
    To protect data transmission, the connection between the frontend and the EMQX broker is secured using Transport Layer Security (TLS). This encryption prevents eavesdropping and tampering, ensuring a confidential and secure communication channel.

- **Automated Device Registration via Secure Webhooks:**
    A webhook secured with JWT authentication is used to register MQTT devices with the backend.

- **Integration with Firebase Cloud Messaging (FCM):**
    Notifications are sent via Firebase if it is installed.

## Project Structure

- **test_notification_app/**: Contains the Flutter application code.
  - **lib/**: Main Dart code for the Flutter application.
  - **android/**: Android-specific configuration and code.
  - **ios/**: iOS-specific configuration and code.
  - **pubspec.yaml**: Flutter project configuration file.
- **backend/**: Contains the Django backend code.
  - **backend/**: Base project package.
    - **settings.py**: Django settings file.
    - **urls.py**: URL routing for the Django backend.
  - **django-emqx/**: Django app for authentication and authorization with the EMQX broker, see [django-emqx](https://github.com/jakobatgithub/django-emqx).
  - **notifications/**: Django app for handling notifications.
  - **Dockerfile**: Dockerfile for building the Django backend image.
  - **manage.py**: Django management script.
  - **requirements.txt**: Python dependencies for the Django backend.
- **emqx/**: Contains configuration files and certificates for EMQX.
  - **emxqx.conf**: Configuration file for the EMQX server.
  - **certs/**: Contains the certificates for TLS.
- **docker-compose.yml**: Docker Compose file for setting up the backend and MQTT broker.
- **README.md**: Project documentation and setup instructions.

## Setup Instructions

### TLS
For transport layer security you need to provide certificates. For development it's useful to create your own Certificate Authority (CA) with [mkcert](https://github.com/FiloSottile/mkcert). Create a new local CA with `mkcert -install` and copy the public root CA certificate `rootCA.pem` (which is created in `mkcert -CAROOT`) to `./certs/`. Create the public/private EMQX server certificates with `mkcert emqx_host_name` and `emqx_host_name` the URL of the EMQX broker and copy both the certificate and key `.pem` files to `./certs/`. For production it might be necessary to use certificates from a public CA as e.g. Let's encrypt.

### Configure Firebase
For the frontend, follow the instructions to add Firebase to your Flutter app: [Firebase Setup](https://firebase.google.com/docs/flutter/setup). Place the `google-services.json` file in `android/app` and `GoogleService-Info.plist` in `ios/Runner` and the iOS Auth key in `ios`. You also need the file `firebase_options.dart` which is generated by FlutterFire CLI and place it in `lib`.
For the backend, place the Firebase Admin SDK JSON file in the `backend` directory and update the path in `settings.py`:
```python
cred = credentials.Certificate("backend/<your-firebase-adminsdk-json>.json")
```

## Usage

### Sending Notifications

- Use the Flutter app to send a POST request to the backend to trigger notifications.
- The backend will send notifications via FCM and MQTT.
- Below the received messages a list of users is shown. If a user is online this is flagged as `connected`. When a device connects to the EMQX broker, then EMQX connects to a Django webhook, which in turn triggers a signal. This signal is then used send an MQTT data message to all connected devices. This triggers the display of the `connected` flag for the corresponding user in the list.

### Receiving Notifications

- The Flutter app will receive notifications and display the latest message along with recent messages.

## License

This project is licensed under the [MIT License](./LICENSE).  
Feel free to use, modify, and distribute â€” just keep the original license and credit.
