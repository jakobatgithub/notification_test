# Notification Test Project

This project showcases the integration of the [django-emqx](https://github.com/jakobatgithub/django-emqx) app to enable real-time messaging using Firebase Cloud Messaging (FCM) and MQTT. The backend is built with Django and the cross-platform frontend with Flutter.

FCM handles push notifications when the app is inactive or in the background but has reliability issues with data messages across devices. To address this, MQTT provides a persistent, bidirectional communication channel for reliable, real-time data delivery. A self-hosted EMQX broker powers MQTT, offering full control over message delivery, QoS, and connections.

We distinguish between notifications and data messages. Notifications consist of a title and a body and no data payload. They are used to inform the user. Data messages have consist of a data payload in form of a JSON dictionary and no title and no body. They are used to trigger changes in the frontend and are not shown to the user.

## Usage

### Sending Notifications

Use the Flutter app to send a POST request to the backend to trigger notifications. The Django backend will send notifications via FCM and MQTT to each registered device. Push notifications sent via FCM are displayed if the app on the device is closed or in the background. MQTT messages are sent if the app is open. Upon starting the app all retained MQTT messages are received and displayed, no MQTT message is ever lost. FCM messages sent while the app is open are never received.

### Display connected users

Below the received messages a list of users is shown. If a user is online this is flagged as `connected`. When a device connects to the EMQX broker, then EMQX connects to a Django webhook, which in turn triggers a signal. This signal then sends a data message to all connected devices. This triggers the display of the `connected` flag for the corresponding user in the list.


## Setup Instructions

### Configure EMQX
Set `BASE_URL` `./backend/backend/settings.py` and `baseURL` in `./test_notification_app/lib/constants.dart` to the URL of the Django backend. Set `mqttBroker` in `./test_notification_app/lib/constants.dart` to the URL of the EMQX broker.

### Configure Firebase
For the frontend, follow the instructions to add Firebase to your Flutter app: [Firebase Setup](https://firebase.google.com/docs/flutter/setup). Place the `google-services.json` file in `android/app` and `GoogleService-Info.plist` in `ios/Runner` and the iOS Auth key in `ios`. You also need the file `firebase_options.dart` which is generated by FlutterFire CLI and place it in `lib`.
For the backend, place the Firebase Admin SDK JSON file in the `backend` directory and update the path in `settings.py`:
```python
cred = credentials.Certificate("backend/<your-firebase-adminsdk-json>.json")
```

### TLS
For transport layer security you need to provide certificates. For development it's useful to create your own Certificate Authority (CA) with [mkcert](https://github.com/FiloSottile/mkcert). Create a new local CA with `mkcert -install` and copy the public root CA certificate `rootCA.pem` (which is created in `mkcert -CAROOT`) to `./certs/`. Create the public/private EMQX server certificates with `mkcert emqx_host_name` and `emqx_host_name` the URL of the EMQX broker and copy both the certificate and key `.pem` files to `./certs/`. For production it might be necessary to use certificates from a public CA as e.g. Let's encrypt.


## Features

This project incorporates several security and efficiency measures to ensure seamless and secure communication between the backend and frontend.

- **Topic-based Access Control:**
    Each frontend user is restricted to a single dedicated MQTT topic for subscriptions, ensuring isolation between users. The backend, however, has the necessary permissions to publish messages to all topics, enabling efficient and controlled message distribution.

- **JWT-based Authentication & Authorization:**
    JSON Web Tokens (JWT) are used for authenticating MQTT clients at EMQX and to enforce access and control lists (ACLs). This ensures that each client has restricted access based on predefined permissions, preventing unauthorized subscriptions or publications. For JWT we use `rest_framework_simplejwt`.

- **Secure communication with TLS:**
    To protect data transmission, the connection between the frontend and the EMQX broker is secured using Transport Layer Security (TLS). This encryption prevents eavesdropping and tampering, ensuring a confidential and secure communication channel. The communication between frontend and Django backend is likewise secured by TLS.

- **Automated Device Registration via Secure Webhooks:**
    A webhook secured with JWT authentication is used to register MQTT devices with the backend.

- **Integration with Firebase Cloud Messaging (FCM):**
    Notifications are sent via Firebase if it is installed.

## Project Structure

- **test_notification_app/**: Contains the Flutter application code.
  - **lib/**: Main Dart code for the Flutter application.
  - **android/**: Android-specific configuration and code.
  - **ios/**: iOS-specific configuration and code.
  - **pubspec.yaml**: Flutter project configuration file.
- **backend/**: Contains the Django backend code.
  - **backend/**: Base project package.
    - **settings.py**: Django settings file.
    - **urls.py**: URL routing for the Django backend.
  - **django-emqx/**: Django app for authentication and authorization with the EMQX broker, see [django-emqx](https://github.com/jakobatgithub/django-emqx).
  - **notifications/**: Django app for handling notifications.
  - **Dockerfile**: Dockerfile for building the Django backend image.
  - **manage.py**: Django management script.
  - **requirements.txt**: Python dependencies for the Django backend.
- **emqx/**: Contains configuration files and certificates for EMQX.
  - **emxqx.conf**: Configuration file for the EMQX server.
  - **certs/**: Contains the certificates for TLS.
- **docker-compose.yml**: Docker Compose file for setting up the backend and MQTT broker.
- **README.md**: Project documentation and setup instructions.


## License

This project is licensed under the [MIT License](./LICENSE).  
Feel free to use, modify, and distribute â€” just keep the original license and credit.
